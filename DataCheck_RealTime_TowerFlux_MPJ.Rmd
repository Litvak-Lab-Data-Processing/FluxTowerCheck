---
title: "MPJ Site Data Check"
author: "Litvak Lab"
output: flexdashboard::flex_dashboard
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# load required libraries
library(flexdashboard)
library(data.table)
library(ggplot2)
library(gridExtra)
library(lubridate)
library(stringr)
library(plotly)
library(tidyr)
library(shiny)
library(units)
library(dplyr)

# ENTER YEAR TO CHECK HERE
yeartocheck <- 2024 

# ENTER SITE TO CHECK HERE (capital first letter, lowercase after)
site <- "Mpj"

# get windrose function, source directly from Github
#source("~/Desktop/R/R_programs/Functions/plot.windrose.R")
source(paste0("https://raw.githubusercontent.com/MargueriteM/R_functions/master/plot.windrose.R"))

#basedir <- paste0("C:/FluxTowerData/", site, "/") # for Jakes computer
basedir <- paste0("~/Desktop/FluxTowerTest/", site, "/")
setwd <- basedir

# Check if the directory exists
if (!dir.exists(basedir)) {
  # Create the directory
  dir.create(basedir, recursive = TRUE)
  message("Directory created: ", basedir)
}

## these are for Vcp, add a loop to fetch for other sites - RD 
file_id <- c("16atuTrnsZOQmXkBAtldTuzAheuAcP39-")  # file ID from google drive 
# file_names <- c(paste0(basedir, "toa5/flux.csv"))  # Corresponding file names; ## this is for Jake's computer
toa5dir <- paste0(basedir, "toa5/")
file_name <- c(paste0(basedir, "toa5/flux.csv"))
file_name_soil <- c(paste0(basedir, "toa5/soil.csv"))
if (!dir.exists(toa5dir)) {
  # Create the directory
  dir.create(toa5dir, recursive = TRUE)
  message("Directory created: ", toa5dir)
}


# Loop through file IDs to download
file_url <- paste0("https://drive.google.com/uc?id=", file_id)
destfile <- file_name
# Check if the destination file exists, and remove it if so
if (file.exists(destfile)) {
    file.remove(destfile)
}
download.file(file_url, destfile, mode = "wb")

# import data directly from google drive
flux_colnames <- fread(paste0(basedir,"/toa5/flux.csv"),
                  header = TRUE, skip=1,sep=",", fill=TRUE,
                 na.strings=c(-9999,"#NAME?"))[1,]

flux_units <- flux_colnames[1,]
flux <- fread(paste0(basedir,"/toa5/flux.csv"),
                  header = FALSE, skip=2, sep=",", fill=TRUE,
                 na.strings=c(-9999,"#NAME?"),
              col.names=colnames(flux_colnames))
flux <- read.csv(paste0(basedir, "/toa5/flux.csv"), header = FALSE, skip = 4)
colnames(flux) <- colnames(flux_colnames)

flux <- data.table(flux)

#convert to numeric 
flux[, 2:ncol(flux) := lapply(.SD, function(x) {
  as.numeric(as.character(x))
}), .SDcols = 2:ncol(flux)]

#convert timestamp to posix
flux$TIMESTAMP <- format(as.POSIXct(flux$TIMESTAMP, tz="MST"), format="%Y-%m-%d %H:%M:%S")
flux <- subset(flux, year(flux$TIMESTAMP) == yeartocheck)

# create derivative date columns
flux[,':=' (year = year(TIMESTAMP), doy = yday(TIMESTAMP), date = as.Date(TIMESTAMP))]
flux$date_time = ymd_hms(flux$TIMESTAMP)

# calculate CO2 ppm from CO2_mean (mg/m^3) 
# https://www.teesing.com/en/page/library/tools/ppm-mg3-converter
flux[,CO2_ppm := (co2_mean_Avg/0.0409)/44.01]

# grab soil data columns 
## currently only set up for Vcp
swc_columns <- c(grep("^SWC_", names(flux), value = TRUE), "TIMESTAMP")

# pull in soil data for PJ 
# Loop through file IDs to download
soil_file_id <- "16hHe-HB0DqY8ptFdk2ymAmHsrcgvNOEJ"
file_url <- paste0("https://drive.google.com/uc?id=", soil_file_id)
destfile <- paste0(basedir, "toa5/", "soil.csv")
# Check if the destination file exists, and remove it if so
if (file.exists(destfile)) {
    file.remove(destfile)
}
download.file(file_url, destfile, mode = "wb")

# import data directly from google drive
soil_colnames <- fread(paste0(basedir,"/toa5/soil.csv"),
                  header = TRUE, skip=1,sep=",", fill=TRUE,
                 na.strings=c(-9999,"#NAME?"))[1,]

soil_units <- soil_colnames[1,]
soil <- fread(paste0(basedir,"/toa5/soil.csv"),
                  header = FALSE, skip=2, sep=",", fill=TRUE,
                 na.strings=c(-9999,"#NAME?"),
              col.names=colnames(soil_colnames))
soil <- read.csv(paste0(basedir, "/toa5/soil.csv"), header = FALSE, skip = 4)
colnames(soil) <- colnames(soil_colnames)

soilsap <- data.table(soil)

#convert to numeric 
soilsap[, 2:ncol(soilsap) := lapply(.SD, function(x) {
  as.numeric(as.character(x))
}), .SDcols = 2:ncol(soilsap)]

#convert timestamp to posix
soilsap$TIMESTAMP <- format(as.POSIXct(soilsap$TIMESTAMP, tz="MST"), format="%Y-%m-%d %H:%M:%S")
soilsap <- subset(soilsap, year(soilsap$TIMESTAMP) == yeartocheck)
#############
soilT_columns <- c(grep("^T_", names(soilsap), value=TRUE), "TIMESTAMP")
soilC_columns <- c(grep("^SCO2", names(soilsap), value=TRUE), "TIMESTAMP")

soil_SWC <- flux[, ..swc_columns]
soil_t <- soilsap[, ..soilT_columns]
soil_C <- soilsap[, ..soilC_columns]

# convert to long format
soilSWC <- soil_SWC %>%
  pivot_longer(-c(TIMESTAMP),names_to="IDcol") %>%
  separate(IDcol, c("metric","pit","depth"), sep="_")
soilSWC <- soilSWC %>%
  separate(pit, into = c("pit_type", "pit_num"), sep = "(?<=\\D)(?=\\d)")
soilSWC$pit_type <- ifelse(soilSWC$pit_type=="O", "open", ifelse(soilSWC$pit_type=="J", "juniper", "pinyon")) 

soilT <- soil_t %>%
  pivot_longer(-c(TIMESTAMP),names_to="IDcol") %>%
  separate(IDcol, c("metric","pit","depth"), sep="_")
soilT <- soilT %>%
  separate(pit, into = c("pit_type", "pit_num"), sep = "(?<=\\D)(?=\\d)")
soilT$pit_type <- ifelse(soilT$pit_type=="O", "open", ifelse(soilT$pit_type=="J", "juniper", "pinyon")) 
soilCO2 <- soil_C %>%
  pivot_longer(-c(TIMESTAMP),names_to="IDcol") %>%
  separate(IDcol, c("metric","pit","depth"), sep="_")
soilCO2 <- soilCO2 %>%
  separate(pit, into = c("pit_type", "pit_num"), sep = "(?<=\\D)(?=\\d)")
soilCO2$pit_type <- ifelse(soilCO2$pit_type=="surf", "Surface_Avg", soilCO2$pit_type )
soilCO2$pit_num <- ifelse(soilCO2$pit_type=="Surface_Avg", "Average", soilCO2$pit_num )

soil <- rbind(soilSWC, soilT, soilCO2)

# format date/time and create depth labels for probes
soil <- soil %>%
  mutate(date_time = ymd_hms(TIMESTAMP),
         date = as.Date(date_time)) 
soil$pit_type <- str_replace(soil$pit_type, "J", "juniper")
soil$pit_type <- str_replace(soil$pit_type, "P", "pinyon")
soil$depth <- str_replace(soil$depth, "Avg", "Surf. Avg")

# set up sap table 
sap_columns <- c(grep("^sap_", names(soilsap), value = TRUE), "TIMESTAMP")

sap_trees <- soilsap[, ..sap_columns]

# convert to long format
sapTrees <- sap_trees %>%
  pivot_longer(-c(TIMESTAMP),names_to="IDcol") %>%
  separate(IDcol, c("metric","tree_probe"), sep="_")

sapTrees <- sapTrees %>%
  mutate(tree_species = substr(tree_probe, 1, 1))
sapTrees <- sapTrees %>%
  mutate(probe = substr(tree_probe, 2, nchar(tree_probe)))

sapTrees$tree_species <- ifelse(sapTrees$tree_species=="P", "pinyon", "juniper")

# format date/time and create depth labels for probes
sapTrees <- sapTrees %>%
  mutate(date_time = ymd_hms(TIMESTAMP),
         date = as.Date(date_time)) 
sapTrees$tree_num <- str_extract(sapTrees$tree_probe, "\\d+")
sapTrees$probeN <- str_extract(sapTrees$probe, "[A-Za-z]$")
```
# Plot Tower Flux and Met Data

Column {.sidebar}
---------------------------------------

###Select Date Range and variables

These graphs show most recent incoming eddy covariance and ancillary data from the tower at the X site. Data are 30min mean values.

**Note: Flux calculations are preliminary and for visualization only!!** 

#### Last timestamp when data sent to server:

```{r, echo=FALSE, warning=FALSE, message=FALSE}

print(max(flux$TIMESTAMP))
```


```{r, echo=FALSE, warning=FALSE, message=FALSE}

dateRangeInput("daterange", "Date range:",
                 start = min(flux$date),
                 end   = max(flux$date),
                 min = min(flux$date),
                 max = max(flux$date))

radioButtons("variable1", "Flux variables:",
             c("CO2 Flux WPL (mg/m2/sec)" = "Fc_wpl",
               "CO2 mean concentration (mg/m3)" = "co2_mean_Avg",
               "CO2 mean ppm (open path)" = "CO2_ppm",
               "Sensible Heat WPL (W/m2)" = "Hc",
               "Latent Heat WPL (W/m2)" = "LE_wpl",
               "H2O mean concentration 1 (open path) (g/m3)" = "h2o_mean_Avg",
               "tau" = "tau",
               "CO2 um m Avg" = "co2_um_m_Avg",
               "H2O mm m Avg" = "h2o_mm_m_Avg",
               "rho_a_mean_Avg" = "rho_a_mean_Avg",
               "rho_a_IRGA" ="rho_a_IRGA",
               "U star" = "u_star"))
```
**When implementing range filter, missing values get connected by a line.**
```{r, echo=FALSE, warning=FALSE, message=FALSE}
 numericInput("range_flux_max","Max range of flux graph",
          value = 1000)

 numericInput("range_flux_min","Min range of flux graph",
            value = -50)

radioButtons("variable1_2", "Sonic Anemometer variables:",
             c("Ux" = "Ux_Avg",
               "Uy" = "Uy_Avg",
               "Uz" = "Uz_Avg"))

 numericInput("range_sonic_max","Max range of Sonic graph",
           value = 30)

 numericInput("range_sonic_min","Min range of Sonic graph",
             value =  -30)

# Choose biomet variable
radioButtons("variable2", "Biomet variables:",
             c("Air temperature, RTD (C)" = "RTD_temp_Avg", 
               "SBTempC_Avg" = "SBTempC_Avg",
               "Air temperature, sonic (C)" = "Ts_Avg",
               "CNR1 Temp Avg (C)" = "CNR1TC_Avg",
               "AirTC_10_Avg" = "AirTC_10_Avg",
               "Precipitation (mm)" = "rain_Tot",
               "Atmospheric pressure (kPa)" = "press_Avg",
               "PAR out (W/m2)" = "par_facedown_Avg",
               "PAR in (W/m2)" = "par_faceup_Avg",
               "Short Wave IN (W/m2)" = "Rad_short_Up_Avg",
               "Short Wave OUT (W/m2)" = "Rad_short_Dn_Avg",
               "Long Wave IN (W/m2)" = "Rad_long_Up_Avg",
               "Long Wave OUT (W/m2)" = "Rad_long_Dn_Avg",
               "CG3 Up Co Avg" = "CG3UpCo_Avg",
               "CG3 Dn Co Avg" = "CG3DnCo_Avg",
               "NetTot_Avg" = "NetTot_Avg",
               "NetRs_Avg" = "NetRs_Avg",
               "NetRl_Avg" = "NetRl_Avg",
               "RH 10 m" = "RH_10_Avg",
               "canopyW_IRT_Avg" ="canopyW_IRT_Avg",
               "canopyE_IRT_Avg" ="canopyE_IRT_Avg",
               "e_hmp_mean_Avg" ="e_hmp_mean_Avg",
               "h2o_hmp_mean_Avg" = "h2o_hmp_mean_Avg",
              "Wind Speed (m/s)" = "rslt_wnd_spd",
              "Wind Speed raw" = "wnd_spd",
              "Wind Direction (compass)" = "wnd_dir_compass",
              "Wind Direction (CSAT)" = "wnd_dir_csat3",
              "Stdev Wind Direction" = "std_wnd_dir",
              "Relative Humidity 10" = "RH_10_Avg"))

numericInput("range_met_max","Max range of Biomet graph",
           value = 40)

numericInput("range_met_min","Min range of Biomet graph",
           value = -20)

radioButtons("variable3", "Instrument variables:",
             c("Battery bank avg (V)" = "battbank_Avg",
               "Battery Bank 1000x (V)" = "batt_1000x_Avg", 
               "AGC/signal strength (unitless)" = "agc_Avg",
               "IRGA warnings"="irga_warnings",
               "CSAT warnings" = "csat_warnings",
               "Datalogger Panel Voltage (V)" = "panelV_Avg",
               "panelT_1000x_Avg" = "panelT_1000x_Avg",
               "n tot" = "n_Tot",
               "CO2_n_Tot" = "CO2_n_Tot",
               "H2O_n_Tot" = "H2O_n_Tot",
               "CSAT_n_Tot" = "CSAT_n_Tot",
               "sync_f_Tot" = "sync_f_Tot",
               "crdFlag_Tot" = "crdFlag_Tot",
               "watchdog 1000" = "watchdog_1000x_Tot",
               "free card space (Mb)"= "crdMbFree",
               "Chopper F total" = "chopper_f_Tot",
               "Low 12V 1000x Tot"= "low12V_1000x_Tot",
               "Skipped Scan" = "SkippedScan",
               "SkippedSystemScan" = "SkippedSystemScan",
               "crdFlag_Tot" = "crdFlag_Tot",
               "days on card" = "daysonCard",
               "sig_lck_f_Tot" = "sig_lck_f_Tot",
               "del_T_f_Tot" = "del_T_f_Tot",
               "amp_h_f_Tot" ="amp_h_f_Tot",
               "amp_l_f_Tot" = "amp_l_f_Tot",
               "detector_f_Tot" = "detector_f_Tot",
               "pll_f_Tot" = "pll_f_Tot",
               "sync_f_Tot" = "sync_f_Tot"
               ))

 
```


Column
-------------------------------------------------------------
```{r, echo = FALSE, warning = FALSE, message = FALSE}
# flux plot

renderPlotly({
  # Prepare Flux Plot
  c_flux <- flux[date >= input$daterange[[1]] & date <= input$daterange[[2]], 
                 .SD, .SDcols = c("date", "date_time", input$variable1)]
  setnames(c_flux, input$variable1, "selected")
  
  fluxP <- ggplot(c_flux, aes(date_time, selected)) +
    geom_line() +
    labs(y = input$variable1) +
    theme_bw()
# 
#   c_flux_sub <- flux %>%
#     pivot_longer(
#       cols = where(is.numeric),
#       names_to = "variable",
#       values_to = "value"
#     ) %>%
#     left_join(lims, by = "variable") 
#   
#   c_flux_goodvals <- subset(c_flux_sub, !value >= max & !value <= min & variable == input$variable1)
#   
#   fluxPgood <- ggplot(c_flux_goodvals, aes(date_time, value)) +
#     geom_line() +
#     labs(y = input$variable1) +
#     theme_bw()
  
  # Prepare Sonic Plot
  c_sonic <- flux[date >= input$daterange[[1]] & date <= input$daterange[[2]], 
                  .SD, .SDcols = c("date", "date_time", input$variable1_2)]
  setnames(c_sonic, input$variable1_2, "selected")
  
  SonicP <- ggplot(c_sonic, aes(date_time, selected)) +
    geom_line() +
    labs(y = input$variable1_2) +
    theme_bw()

  # Prepare Biomet Plot
  c_biomet <- flux[date >= input$daterange[[1]] & date <= input$daterange[[2]], 
                   .SD, .SDcols = c("date", "date_time", input$variable2)]
  setnames(c_biomet, input$variable2, "selected")
  
  BiometP1 <- ggplot(c_biomet, aes(date_time, selected)) +
    geom_line() +
    labs(y = input$variable2) +
    theme_bw()
  # 
  # #biomet in range only
  # c_biomet_sub <- flux %>%
  #   pivot_longer(
  #     cols = where(is.numeric),
  #     names_to = "variable",
  #     values_to = "value"
  #   ) %>%
  #   left_join(lims, by = "variable") 
  # 
  # c_flux_goodvals <- subset(c_flux_sub, !value >= max & !value <= min & variable == input$variable2)
  # 
  # biometPgood <- ggplot(c_flux_goodvals, aes(date_time, value)) +
  #   geom_line() +
  #   labs(y = input$variable2) +
  #   theme_bw()

  # Prepare Diagnostics Plot
  c_diag <- flux[date >= input$daterange[[1]] & date <= input$daterange[[2]], 
                 .SD, .SDcols = c("date", "date_time", input$variable3)]
  setnames(c_diag, input$variable3, "selected")
  
  InstP <- ggplot(c_diag, aes(date_time, selected)) +
    geom_line() +
    labs(y = input$variable3) +
    theme_bw()

  # Convert to plotly
  p1 <- ggplotly(fluxP) %>% layout(title = list(text = "Flux Variables"))
 # p1b <- ggplotly(fluxPgood) %>% layout(title=list(text="Flux Variables, in range only"))
  p2 <- ggplotly(SonicP) %>% layout(title = list(text = "Sonic Anemometer Variables"))
  p3 <- ggplotly(BiometP1) %>% layout(title = list(text = "Biomet Variables"))
 # p3b <- ggplotly(biometPgood) %>% layout(title = list(text = "Biomet Variables, in range only"))
  p4 <- ggplotly(InstP) %>% layout(title = list(text = "Instrument Variables"))

  # Combine with subplot and set layout properties
  plotly::subplot(p1, p2, p3, p4, nrows = 4, shareX = TRUE, titleX = TRUE, titleY = TRUE) %>%
    layout(
      height = 1500,
       margin = list(
        l = 80,   # Left margin
        r = 200,  # Increased right margin to accommodate legends
        t = 75,   # Top margin
        b = 50    # Bottom margin
      ),
      annotations = list(
        list(x = 0.1, y = 1.02, text = "Flux Variables", showarrow = FALSE, xref = "paper", yref = "paper"),
       # list(x=0.1, y = 0.85, text = "Flux Variables, in range only", showarrow = FALSE, xref ="paper", yref="paper"),
        list(x = 0.1, y = 0.67, text = "Sonic Anemometer Variables", showarrow = FALSE, xref = "paper", yref = "paper"),
        list(x = 0.1, y = 0.49, text = "Biomet Variables", showarrow = FALSE, xref = "paper", yref = "paper"),
  #      list(x = 0.1, y = 0.32, text = "Biomet Variables, in range only", showarrow = FALSE, xref = "paper", yref = "paper"),
        list(x = 0.1, y = 0.15, text = "Instrument Variables", showarrow = FALSE, xref = "paper", yref = "paper")
      )
    )
})

```


# Windrose {data-orientation=rows}

Row {data-height=75}
-------------------------------------------------------------
Select Date Range for Wind Rose
```{r, echo=FALSE, warning=FALSE, message=FALSE}

dateRangeInput("daterange2", "Date range:",
                 start = min(flux$date),
                 end   = max(flux$date),
                 min = min(flux$date),
                 max = max(flux$date))

```

Row {data-height=450}
-------------------------------------------------------------
Wind Rose in Compass direction
```{r, echo = FALSE, warning = FALSE, message = FALSE}
# Wind direction from Sonic Anemometer
 renderPlot({
 wind.data <-  flux %>%
   filter((date >= input$daterange2[[1]] & date <= input$daterange2[[2]])) 
 # plot wind variables in windrose
   plot.windrose(wind.data,wind.data$rslt_wnd_spd,wind.data$wnd_dir_compass) +
   labs(title="CSAT3")+
     theme(legend.position="bottom")
 })

```


# Tower Soil Moisture Profile and Met Data

Column {.sidebar}
---------------------------------------

#### Last timestamp when data sent to server:

```{r, echo=FALSE, warning=FALSE, message=FALSE}

print(max(soil$date_time))
```


```{r, echo=FALSE, warning=FALSE, message=FALSE}

dateRangeInput("daterange3", "Date range:",
                 start = min(soil$date),
                 end   = max(soil$date),
                 min = min(soil$date),
                 max = max(soil$date))


radioButtons("variable1_3", "Soil variables:",
             c("Temperature (C)" = "T",
               "Volumetric Water Content m3/m3)" = "SWC",
               "Soil CO2" = "SCO2"))

radioButtons("variable2_3a", "Soil Depth:",
             c("5cm"="5",
               "10cm"= "10",
               "30cm"="30",
               "Surf. Avg" = "Surf. Avg"))

radioButtons("variable3a", "Pit Type:",
             c("open" = "open",
               "juniper" = "juniper",
               "pinyon" = "pinyon"))

radioButtons("variable3b", "Pit Number:",
             c("1" = "1",
               "2" = "2",
               "3" = "3",
               "4" = "4",
               "5" = "5",
               "Avg"= "Average"))

radioButtons("variable3_3", "Biomet variables:",
              c("Air temperature, RTD (C)" = "RTD_temp_Avg", 
               "SBTempC_Avg" = "SBTempC_Avg",
               "Air temperature, sonic (C)" = "Ts_Avg",
               "CNR1 Temp Avg (C)" = "CNR1TC_Avg",
               "AirTC_10_Avg" = "AirTC_10_Avg",
               "Precipitation (mm)" = "rain_Tot",
               "Atmospheric pressure (kPa)" = "press_Avg",
               "PAR out (W/m2)" = "par_facedown_Avg",
               "PAR in (W/m2)" = "par_faceup_Avg",
               "Short Wave IN (W/m2)" = "Rad_short_Up_Avg",
               "Short Wave OUT (W/m2)" = "Rad_short_Dn_Avg",
               "Long Wave IN (W/m2)" = "Rad_long_Up_Avg",
               "Long Wave OUT (W/m2)" = "Rad_long_Dn_Avg",
               "CG3 Up Co Avg" = "CG3UpCo_Avg",
               "CG3 Dn Co Avg" = "CG3DnCo_Avg",
               "NetTot_Avg" = "NetTot_Avg",
               "NetRs_Avg" = "NetRs_Avg",
               "NetRl_Avg" = "NetRl_Avg",
               "RH 10 m" = "RH_10_Avg",
               "canopyW_IRT_Avg" ="canopyW_IRT_Avg",
               "canopyE_IRT_Avg" ="canopyE_IRT_Avg",
               "e_hmp_mean_Avg" ="e_hmp_mean_Avg",
               "h2o_hmp_mean_Avg" = "h2o_hmp_mean_Avg",
              "Wind Speed (m/s)" = "rslt_wnd_spd",
              "Wind Speed raw" = "wnd_spd",
              "Wind Direction (compass)" = "wnd_dir_compass",
              "Wind Direction (CSAT)" = "wnd_dir_csat3",
              "Stdev Wind Direction" = "std_wnd_dir",
              "Relative Humidity 10" = "RH_10_Avg"))


```

Column 
---------------------------------------

```{r, echo=FALSE, warning=FALSE, message=FALSE}

soil <- subset(soil, value > -100)
 # Soil Plot, All depths in one 
renderPlot({
   soil$depth <- factor(soil$depth, levels = c("5", "10", "30"))
  # Soil Faceted Plot
  soil_faceted_data <- soil %>%
    filter((date >= input$daterange3[[1]] & date <= input$daterange3[[2]]) &
           metric == input$variable1_3)

  soil_facetedPlot <- ggplot(soil_faceted_data, aes(date_time, value, colour = pit_num)) +
    geom_line() +
    facet_grid(depth ~ pit_type, scales = "free_y") +
    labs(y = input$variable1_3) +
    theme_bw() +
    theme(legend.position = "right")

  # Soil Selected pit
  soil_selected_pit_data <- soil %>%
    filter((date >= input$daterange3[[1]] & date <= input$daterange3[[2]]) &
           metric == input$variable1_3 &
           pit_type == input$variable3a & 
           pit_num == input$variable3b)

  soil_selected_pitPlot <- ggplot(soil_selected_pit_data, aes(date_time, value, colour = depth)) +
    geom_line() +
    labs(y = input$variable1_3) +
    theme_bw() +
    theme(legend.position = "right")

  # Soil Selected Depth
  soil_selected_depth_data <- soil %>%
    filter((date >= input$daterange3[[1]] & date <= input$daterange3[[2]]) &
           metric == input$variable1_3 &
           depth == input$variable2_3a)

  soil_selected_depthPlot <- ggplot(soil_selected_depth_data, aes(date_time, value, color = pit_num)) +
    geom_line() +
    labs(y = input$variable1_3) +
    facet_grid(depth ~ ., scales = "free_y") +
    theme_bw() +
    theme(legend.position = "right")

  # Biomet Plot
  c_biomet <- flux[date >= input$daterange[[1]] & date <= input$daterange[[2]], 
                   .SD, .SDcols = c("date", "date_time", input$variable3_3)]
  setnames(c_biomet, input$variable3_3, "selected")

  BiometP1 <- ggplot(c_biomet, aes(date_time, selected)) +
    geom_line() +
    labs(y = input$variable3_3) +
    theme_bw()

  # Convert to plotly objects
  p1 <- ggplotly(soil_facetedPlot) %>%
    layout(
      showlegend = TRUE, 
      legend = list(
        orientation = "v",  # Vertical legend
        x = 1.1,            # Move legend to the right
        y = 1
      )
    )
  p2 <- ggplotly(soil_selected_pitPlot) %>%
    layout(
      showlegend = TRUE, 
      legend = list(
        orientation = "v",
        x = 1.1,
        y = 1
      )
    )
  p3 <- ggplotly(soil_selected_depthPlot) %>%
    layout(
      showlegend = TRUE, 
      legend = list(
        orientation = "v",
        x = 1.1,
        y = 1
      )
    )
  p4 <- ggplotly(BiometP1) %>%
    layout(
      showlegend = TRUE, 
      legend = list(
        orientation = "v",
        x = 1.1,
        y = 1
      )
    )
  
  # Combine subplots
  plotly::subplot(p1, p2, p3, p4, nrows = 4, shareX = TRUE, titleX = TRUE, titleY = TRUE) %>%
    layout(
      height = 1200,
      margin = list(
        l = 80,   # Left margin
        r = 200,  # Increased right margin to accommodate legends
        t = 75,   # Top margin
        b = 50    # Bottom margin
      ),
      annotations = list(
        list(
          x = 0.5, y = 1.05, text = "Soil, All Depths Separately", 
          showarrow = FALSE, xref = "paper", yref = "paper", 
          font = list(size = 14)
        ),
        list(
          x = 0.5, y = 0.75, text = "Soil, Selected Pit", 
          showarrow = FALSE, xref = "paper", yref = "paper", 
          font = list(size = 14)
        ),
        list(
          x = 0.5, y = 0.5, text = "Soil, Selected Depth", 
          showarrow = FALSE, xref = "paper", yref = "paper", 
          font = list(size = 14)
        ),
        list(
          x = 0.5, y = 0.25, text = "Biomet Variables", 
          showarrow = FALSE, xref = "paper", yref = "paper", 
          font = list(size = 14)
        )
      )
    )
   })

```

# Sap Sensors

Column {.sidebar}
---------------------------------------

```{r, echo=FALSE, warning=FALSE, message=FALSE}

# create a sap data frame 

dateRangeInput("daterange4", "Date range:",
                 start = min(soilsap$date),
                 end   = max(sapTrees$date),
                 min = min(sapTrees$date),
                 max = max(sapTrees$date))

radioButtons("variable4_1", "Tree Species:",
             c("pinyon" = "pinyon",
               "juniper" = "juniper"))

radioButtons("variable4_2", "Soil variables:",
             c("Temperature (C)" = "T",
               "Volumetric Water Content m3/m3)" = "SWC",
               "Soil CO2" = "SCO2"))

radioButtons("variable4_3", "Biomet variables:",
             c("Air temperature, hmp (C)" = "RTD_temp_Avg",
               "Air temperature, sonic (C)" = "Ts_Avg",
               "Atmospheric pressure (kPa)" = "press_Avg",
               "Precipitation (mm)" = "rain_Tot",
               "PAR out (W/m2)" = "par_face_down_Avg",
               "PAR in (W/m2)" = "par_face_up_Avg",
               "Short Wave IN (W/m2)" = "Rad_short_Up_Avg",
               "Short Wave OUT (W/m2)" = "Rad_short_Dn_Avg",
               "Long Wave IN (W/m2)" = "Rad_long_Up_Avg",
               "Long Wave OUT (W/m2)" = "Rad_long_Dn_Avg",
              "Wind Speed (m/s)" = "wnd_spd",
              "Wind Direction (degrees)" = "wnd_dir_compass"))
```

Column 
---------------------------------------

```{r, echo=FALSE, warning=FALSE, message=FALSE}

# Sap Plot, All trees faceted 
renderPlotly({
   sapTreesDF1 <- sapTrees %>%
      filter((date >= input$daterange4[[1]] & date <= input$daterange4[[2]]) & 
    tree_species==input$variable4_1) 
    
  SapPlotAll <-  ggplot(sapTreesDF1, aes(date_time, value, colour=probeN))+
     geom_line()+
     facet_grid(tree_num~., scales="free_y")+
    labs(title = "Sap Flow", y="sap flow")+
 theme_bw()+
    theme(legend.position="bottom")
  ggplotly(SapPlotAll)
  })

 # Soil Plot, All depths in one 
renderPlotly({
     soilsapdf <- soil %>%
       filter((date >= input$daterange4[[1]] & date <= input$daterange4[[2]]) & 
     metric==input$variable1_3)
     
  soilsapP <- ggplot(soilsapdf, aes(date_time, value, colour=pit_num))+
      geom_line()+
    facet_grid(depth~pit_type, scales = "free_y") + 
     labs(title = "All Depths", y=input$variable4_2)+
  theme_bw()+
     theme(legend.position="bottom")
  ggplotly(soilsapP)
   })

# biomet variable plot
renderPlotly({
    c <- flux[date >= input$daterange4[[1]] & date <= input$daterange4[[2]],.SD,.SDcols=c("date","date_time",input$variable4_3)]
  
    setnames(c,input$variable4_3,"selected")
  
  # plot_ly(c,x=~date_time,y=~airtemp, type="scatter")},
  # ggplot(c[selected>=input$range_met_min & selected<=input$range_met_max,], aes(date_time, selected))+
   soilmetP <- ggplot(c, aes(date_time, selected))+
     geom_line()+
    labs(title = "Biomet variables", y=input$variable4_3)+
 theme_bw()
   ggplotly(soilmetP)})

```
